# Project Title: CS_ino_50
###### By: Luke O'Neil
#### Video Demo:  <https://www.youtube.com/watch?v=4Vxu8hDHiKg>

#### Description:
My goal was to create a simple Python casino that would allow a user to bet on either a game of slots or roulette. I separated my project into a main file as well as three additional files for the classes that I wanted to create. The other problem sets I submitted were not written with OOP in mind, so I wanted to do my best to practice it with the final project.

The player_class file contains the Player class and all of their stored information. I made it easy to instantiate a player by prompting the user for an input, and then randomly assigning them a balance between 10-100$ to bet with. I included error checking to ensure that the name is alphabetical. After the player class is instantiated, a method exists to set the gamechoice attribute which the main function uses to evaluate whether it calls on the slots class or the roulette class. After this, a method “bet” exists to set the instance variable of amount equal to a value and then to subtract it from the player’s balance. Error checking exists to ensure that bets placed have to be less than the player’s balance and above 0. If the game being played is roulette, the “r_bet” method sets a bet_type  variable equal to whatever the player decides to bet on (red, black, numbers etc).  Additionally, a “get_num” method exists to store a player’s number choice if they are betting numbers on roulette. The final method for this class is “check” which I use to see if the user’s balance has fallen to zero after a game is finished, causing the program to exit with a prompt informing the user of this.

The slots_class file contains the Slot class and is used to play a game of slots. When the Slot.play method is called, variables first, second and third are each assigned a random emoji out of three. If the three variables match, then an instance variable of winnings is set to five times the bet amount. The aforementioned Player.check method adds any winnings to the player’s balance and then prints their available balance after each game. If the three variables with stored emojis don’t match, winnings are set to 0.

The roulette_class file contains the Roulette class and is used to play a game of roulette. A method called “spin” randomly sets instance variables for number and color equal to 0-38 and red or black respectively. Methods exist for each of the betting types that can occur, which include: red, black, even, odd and numbers. These methods check the appropriate instance variable of either color or number to see if the player has won. Any win other than numbers stores a winnings of double the bet amount, while winning a numbers bet store a winnings of 35 times the bet amount. This is because the odds of the first methods are 1 in 2 while the odds of a numbers bet is 1 in 39. Once again, the Player.check method adds any winnings to the player’s balance and then prints this for them.

The CS_ino_50 file imports the three classes and calls on their methods using a main function. “While True” loops are implemented to allow the player to continue playing until they run out of money or exit with CMD/CTRL-D. Conditional statements are the main driver of setting the game and verifying which bet type the user chose, as well as the bet amount. Stylistically, I added line breaks to the beginning and end of many print statements to separate each line that the program prints to the user after betting and game implementation.

The project file includes the main function as well as all of the class functions for testing purposes. I struggled with pytest testing until I added rigged methods to the slots and roulette methods to ensure that the winnings were being properly multiplied when the user won and that picking the wrong variables as a bet resulted in a loss. This is why the class files have methods such as testwin or testloss. I also made sure that you could instantiate a custom player with a set amount of money if you wished to do so. Many of the tests use the capsys method to look at the output of the methods, since many of them didn’t return any values, but simply altered the instance variables.

After thorough testing, the program runs as intended, allowing the user to play games in a loop until they run out of money or exit out of the program. Each time the loop repeats, the game variables are scrambled so the user can’t use past results to inform their current bets.



